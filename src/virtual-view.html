<polymer-element name="virtual-view" hidden attributes="target el discardAttr">
  <template>
    <states-helper id="helper"></states-helper>
  </template>
  <script>
    (function() {
      Polymer({

        virtualHolder: '__$virtual$',

        ready: function() {
          var template = this.firstElementChild;
          if (!template) {
            template = document.createElement('template');
            this.appendChild(template);
          }
        },

        created: function() {
          this.holderCache = document.createElement('view-registry').getCache('place-holder:id');
          this.cache = document.createElement('view-registry').getCache('virtual-view:target');

          this.target = this.getAttribute('target');
          if (!this.target) {
            this.target = this.virtualHolder;
            this.setAttribute('target', this.target);
          }

          var stateviews = this.cache.get(this.target);
          if (!stateviews)
            this.cache.set(this.target, [this]);
          else stateviews.push(this);

          var discardAttr = ['ID', 'TARGET', 'HIDDEN', 'EL', 'DISCARDATTR'];

          if (this.hasAttribute('discardAttr')) {
            var attr = this.getAttribute('discardAttr').split(' ');
            attr.forEach(function(item) {
              discardAttr.push(item.toUpperCase());
            });
          }

          this.discardAttr = discardAttr;
        },

        detached: function() {
          delete this.instance;
          var stateviews = this.cache.get(this.target);
          if (stateviews && stateviews.length)
            if (stateviews.indexOf(this) >= 0)
              stateviews.splice(stateviews.indexOf(this), 1);
        },

        changeModel: function(model) {
          // Ideally we should just set new model but it doesn't work as expected.
          var targetModel = this.templateUsed ? this.instance.templateInstance.model : this.instance;
          for (var property in model) {
            if (model.hasOwnProperty(property)) {
              targetModel[property] = model[property];
            }
          }
        },

        clearContent: function() {
          if (!this.instance)
            return;
          var holder = this.holderCache.get(this.target);
          if (!holder && this.target != this.virtualHolder) {
            console.log('virtual-view:Clear: Cannot locate target ' + this.target);
          } else {
            if (holder) {
              holder.remove();
            } else
              document.body.removeChild(this.instance);
            delete this.instance;
            delete this.templateUsed;
          }
        },


        loadInto: function(holder, model) {
          var instance, self = this;

          if (holder) {
            var instances = this.cache.get(this.target);
            instances.forEach(function(presenter) {
              if (self != presenter && presenter.instance && presenter.target != self.virtualHolder)
                presenter.clearContent();
            });
            if (holder.content)
              holder.remove();
          }

          var template = this.firstElementChild;
          if (!template) {
            template = document.createElement('template');
            this.appendChild(template);
            var elInstance = document.createElement(this.el);
            template.appendChild(elInstance);
          }

          if (!template) {
            instance = document.createElement(this.el);
          } else {
            template = this.firstElementChild;
            if (template && template.tagName == 'TEMPLATE') {
              instance = template.createInstance(model);
              this.templateUsed = true;
            }
          }

          if (instance) {
            if (holder) {
              this.instance = instance;
              if (!this.templateUsed) {
                for (var property in model) {
                  if (model.hasOwnProperty(property)) {
                    instance[property] = model[property];
                  }
                }
              }
              holder.place(instance);

            } else {
              if (this.templateUsed) {
                var foo = document.createElement('div');
                foo.appendChild(instance);
                this.instance = foo;
              } else this.instance = instance;
              document.body.appendChild(this.instance);
            }
          }

        },

        loadContent: function(model) {
          if (this.instance) {
            throw Error('Presenter already loaded. Clear first.');
          }
          var holder = this.holderCache.get(this.target);
          if (!holder && this.target != this.virtualHolder) {
            throw Error('Presenter should have a valid el attribute or first child should be template element.');
          } else {
            this.loadInto(holder, model);
          }
        }
      });

    })();
  </script>

</polymer-element>
